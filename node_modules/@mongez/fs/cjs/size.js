'use strict';var isDirectory=require('./isDirectory.js'),stats=require('./stats.js'),path=require('path'),fs=require('fs');function _interopDefault(e){return e&&e.__esModule?e:{default:e}}var path__default=/*#__PURE__*/_interopDefault(path);var fs__default=/*#__PURE__*/_interopDefault(fs);/**
 * Get size of the given path either file or directory in bytes
 */
function pathSize(path) {
    if (isDirectory.isDirectory(path)) {
        return directorySize(path) || 0;
    }
    try {
        return stats.stats(path).size;
    }
    catch (e) {
        return 0;
    }
}
const fileSize = pathSize;
function directorySize(folderPath) {
    let totalSize = 0;
    try {
        const files = fs__default.default.readdirSync(folderPath);
        for (const file of files) {
            const filePath = path__default.default.join(folderPath, file);
            const stats = fs__default.default.statSync(filePath);
            if (stats.isFile()) {
                totalSize += stats.size;
            }
            else if (stats.isDirectory()) {
                totalSize += directorySize(filePath);
            }
        }
        return totalSize;
    }
    catch (error) {
        throw error;
    }
}
/**
 * Get the size of the given path async
 */
async function pathSizeAsync(path) {
    return new Promise(async (resolve, reject) => {
        try {
            if (await isDirectory.isDirectoryAsync(path)) {
                directorySizeAsync(path, (error, bytes) => {
                    if (error) {
                        reject(error);
                    }
                    else if (bytes) {
                        resolve(bytes);
                    }
                });
            }
            else {
                resolve((await stats.statsAsync(path)).size);
            }
        }
        catch (error) {
            reject(error);
        }
    });
}
const fileSizeAsync = pathSizeAsync;
async function directorySizeAsync(folderPath) {
    let totalSize = 0;
    try {
        const files = await fs__default.default.promises.readdir(folderPath);
        for (const file of files) {
            const filePath = path__default.default.join(folderPath, file);
            const stats = await fs__default.default.promises.stat(filePath);
            if (stats.isFile()) {
                totalSize += stats.size;
            }
            else if (stats.isDirectory()) {
                totalSize += await directorySizeAsync(filePath);
            }
        }
        return totalSize;
    }
    catch (error) {
        throw error;
    }
}
/**
 * Get the size if the given path and convert it to human readable format
 */
function humanSize(path) {
    const bytes = pathSize(path);
    return calculateSize(bytes);
}
function calculateSize(bytes) {
    const sizes = ["Bytes", "KB", "MB", "GB", "TB"];
    if (bytes === 0) {
        return "0 Byte";
    }
    const i = Math.floor(Math.log(bytes) / Math.log(1024));
    return `${(bytes / 1024 ** i).toFixed(2)} ${sizes[i]}`;
}
// async version
async function humanSizeAsync(path) {
    return new Promise(async (resolve, reject) => {
        try {
            const bytes = await pathSizeAsync(path);
            resolve(calculateSize(bytes));
        }
        catch (error) {
            reject(error);
        }
    });
}exports.directorySize=directorySize;exports.directorySizeAsync=directorySizeAsync;exports.fileSize=fileSize;exports.fileSizeAsync=fileSizeAsync;exports.humanSize=humanSize;exports.humanSizeAsync=humanSizeAsync;exports.pathSize=pathSize;exports.pathSizeAsync=pathSizeAsync;//# sourceMappingURL=size.js.map
