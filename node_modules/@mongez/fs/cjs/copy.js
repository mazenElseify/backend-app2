'use strict';var fs=require('fs'),path=require('path'),isFile=require('./isFile.js');function _interopDefault(e){return e&&e.__esModule?e:{default:e}}var fs__default=/*#__PURE__*/_interopDefault(fs);var path__default=/*#__PURE__*/_interopDefault(path);/**
 * Copy the given source to the new target
 */
function copyPath(source, target) {
    if (isFile.isFile(source)) {
        return fs__default.default.copyFileSync(source, target);
    }
    return copyDirectory(source, target);
}
/**
 * Copy the given source file to the new target file
 */
function copyFile(source, target) {
    fs__default.default.copyFileSync(source, target);
}
/**
 * Copy the given source directory to the new target directory
 */
function copyDirectory(source, destination) {
    // Create the destination directory if it doesn't exist
    if (!fs__default.default.existsSync(destination)) {
        fs__default.default.mkdirSync(destination, { recursive: true });
    }
    // Read all the items (files and subdirectories) from the source directory
    const items = fs__default.default.readdirSync(source, { withFileTypes: true });
    items.forEach((item) => {
        const sourcePath = path__default.default.join(source, item.name);
        const destinationPath = path__default.default.join(destination, item.name);
        if (item.isDirectory()) {
            // If it's a directory, recurse into it
            copyDirectory(sourcePath, destinationPath);
        }
        else {
            // If it's a file, copy it
            fs__default.default.copyFileSync(sourcePath, destinationPath);
        }
    });
}
/**
 * @async Copy the given source to the new target
 */
async function copyPathAsync(source, target) {
    try {
        if (isFile.isFile(source)) {
            return await fs__default.default.promises.copyFile(source, target);
        }
        return await copyDirectoryAsync(source, target);
    }
    catch (error) {
        throw error;
    }
}
/**
 * @async Copy the given source directory to the new target directory
 */
function copyFileAsync(source, target) {
    return fs__default.default.promises.copyFile(source, target);
}
/**
 * @async Copy the given source directory to the new target directory
 */
async function copyDirectoryAsync(source, destination) {
    try {
        // Check if the destination directory exists, if not, create it
        await fs__default.default.promises.mkdir(destination, { recursive: true });
        // Read all the items (files and subdirectories) from the source directory
        const items = await fs__default.default.promises.readdir(source, { withFileTypes: true });
        for (const item of items) {
            const sourcePath = path__default.default.join(source, item.name);
            const destinationPath = path__default.default.join(destination, item.name);
            if (item.isDirectory()) {
                // If it's a directory, recurse into it
                await copyDirectoryAsync(sourcePath, destinationPath);
            }
            else {
                // If it's a file, copy it
                await fs__default.default.promises.copyFile(sourcePath, destinationPath);
            }
        }
    }
    catch (error) {
        console.error("Error copying directory:", error);
    }
}exports.copyDirectory=copyDirectory;exports.copyDirectoryAsync=copyDirectoryAsync;exports.copyFile=copyFile;exports.copyFileAsync=copyFileAsync;exports.copyPath=copyPath;exports.copyPathAsync=copyPathAsync;//# sourceMappingURL=copy.js.map
